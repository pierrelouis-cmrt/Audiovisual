<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>The art of listening — audiovisual piece (v5)</title>
    <style>
      :root {
        --light-a: 255, 204, 51;
        --light-b: 255, 153, 0;
        --light-c: 255, 238, 136;
        --light-intensity: 0.1;
      }
      html,
      body {
        margin: 0;
        height: 100%;
        overflow: hidden;
        background: #14100b;
        color: #efe7d6;
        cursor: none;
      }
      @import url("https://fonts.googleapis.com/css2?family=Anton&display=swap");

      canvas#gl {
        position: fixed;
        inset: 0;
        width: 100%;
        height: 100%;
        display: block;
        pointer-events: none;
      }

      .noise-overlay {
        position: fixed;
        inset: -25% -25%;
        width: 150%;
        height: 150%;
        background-size: 180px 180px;
        opacity: 0.18;
        mix-blend-mode: soft-light;
        pointer-events: none;
        z-index: 9;
        filter: contrast(115%) brightness(100%);
      }

      .overlay {
        position: fixed;
        inset: 0;
        display: grid;
        place-items: center;
        text-align: center;
        z-index: 20;
        pointer-events: none;
      }
      .overlay .caption {
        font-family: "Bodoni Moda", serif;
        font-style: italic;
        letter-spacing: 0.06em;
        font-size: 1rem;
        opacity: 0.75;
      }

      .overlay .quote {
        font-family: "Anton", sans-serif;
        font-weight: 900;
        text-transform: uppercase;
        font-size: clamp(3rem, 9vw, 8rem);
        letter-spacing: 0.02em;
        color: rgba(255, 255, 255, 0.75);
        -webkit-text-stroke: 1px rgba(255, 255, 255, 0.95);
      }

      .overlay .attributions {
        font-family: "Bodoni Moda", serif;
        font-style: italic;
        opacity: 0.75;
      }

      .controls {
        position: fixed;
        top: 14px;
        left: 14px;
        z-index: 30;
        pointer-events: auto;
      }
      .btn {
        padding: 8px 16px;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        background: rgba(20, 20, 20, 0.35);
        color: #fff;
        font-weight: 500;
        cursor: pointer;
        backdrop-filter: blur(8px) saturate(120%);
        font-size: 0.85rem;
        opacity: 0.7;
        transition: opacity 0.2s ease;
      }
      .btn:hover {
        opacity: 1;
      }

      .fps {
        position: fixed;
        top: 14px;
        right: 14px;
        padding: 6px 12px;
        border-radius: 999px;
        z-index: 30;
        font-family: ui-monospace, monospace;
        font-size: 12px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        background: rgba(20, 20, 20, 0.35);
        backdrop-filter: blur(8px) saturate(120%);
        opacity: 0.6;
        transition: opacity 0.2s ease;
      }
      .fps:hover {
        opacity: 1;
      }

      .cursor {
        position: fixed;
        width: 14px;
        height: 14px;
        border-radius: 50%;
        background: rgba(255, 215, 120, 0.95);
        box-shadow: 0 0 20px rgba(255, 220, 120, 0.9);
        transform: translate(-50%, -50%);
        z-index: 100;
        pointer-events: none;
        transition: filter 0.15s ease;
      }
      .cursor.snap {
        filter: brightness(1.6);
      }
    </style>
  </head>
  <body>
    <canvas id="gl"></canvas>
    <div class="noise-overlay" id="noise"></div>

    <div class="overlay">
      <div>
        <div class="caption">Find beauty in the space between sound</div>
        <div class="quote">The art of listening</div>
        <div class="attributions">
          “When you learn to see the invisible, you create the impossible.”<br />Music
          by KOSIKK
        </div>
      </div>
    </div>

    <div class="controls"><button class="btn" id="playBtn">Play</button></div>
    <div class="fps" id="fps">FPS: —</div>
    <div class="cursor" id="cursor"></div>

    <script type="module">
      import * as THREE from "https://unpkg.com/three@0.160.1/build/three.module.js";

      const AUDIO_URL = "https://assets.codepen.io/7558/kosikk-slow-motion.ogg";
      let audioCtx,
        audioEl,
        sourceNode,
        analyser,
        isPlaying = false;
      const FFT_SIZE = 1024;
      let sampleRate = 44100;
      const freqData = new Uint8Array(FFT_SIZE / 2);
      function setupAudio() {
        if (audioCtx) return;
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        sampleRate = audioCtx.sampleRate;
        audioEl = new Audio();
        audioEl.crossOrigin = "anonymous";
        audioEl.src = AUDIO_URL;
        audioEl.loop = true;
        analyser = audioCtx.createAnalyser();
        analyser.fftSize = FFT_SIZE;
        analyser.smoothingTimeConstant = 0.7;
        sourceNode = audioCtx.createMediaElementSource(audioEl);
        sourceNode.connect(analyser);
        analyser.connect(audioCtx.destination);
      }

      const renderer = new THREE.WebGLRenderer({
        canvas: document.getElementById("gl"),
        antialias: true,
      });
      renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
      renderer.setSize(innerWidth, innerHeight);
      const scene = new THREE.Scene();
      const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
      const uniforms = {
        u_time: { value: 0 },
        u_res: { value: new THREE.Vector2(innerWidth, innerHeight) },
        u_low: { value: 0 },
        u_mid: { value: 0 },
        u_high: { value: 0 },
        u_bgTop: { value: new THREE.Color("#2a1e0c") },
        u_bgBottom: { value: new THREE.Color("#14100b") },
        u_colA_in: { value: new THREE.Color("#ffcc33") },
        u_colA_out: { value: new THREE.Color("#ff8800") },
        u_colB_in: { value: new THREE.Color("#ffee88") },
        u_colB_out: { value: new THREE.Color("#ff9900") },
        u_colC_in: { value: new THREE.Color("#fff3aa") },
        u_colC_out: { value: new THREE.Color("#ffbb33") },
        u_thickness: { value: 0.02 },
        u_noiseTex: { value: null },
        u_phaseA: { value: 0 },
        u_phaseB: { value: 0 },
        u_phaseC: { value: 0 },
      };

      const material = new THREE.ShaderMaterial({
        uniforms,
        vertexShader: `varying vec2 vUv; void main(){ vUv = uv; gl_Position = vec4(position,1.0); }`,
        fragmentShader: `
varying vec2 vUv;
uniform vec2 u_res;
uniform float u_time;
uniform float u_low,u_mid,u_high;
uniform vec3 u_bgTop,u_bgBottom,u_colA_in,u_colA_out,u_colB_in,u_colB_out,u_colC_in,u_colC_out;
uniform sampler2D u_noiseTex;
uniform float u_thickness;
uniform float u_phaseA, u_phaseB, u_phaseC;

float grain(vec2 uv){ return texture2D(u_noiseTex, uv*vec2(u_res.x/u_res.y,1.0)*0.75).r*2.0-1.0; }
float sdLineY(vec2 uv, float y){ return abs(uv.y - y); }
float gauss(float d, float s){ return exp(-(d*d)/(2.0*s*s)); }

// slight always-on + reactive glow
vec3 stripe(vec2 uv, float y, vec3 cIn, vec3 cOut, float thick, float intens){
  float d = sdLineY(uv, y);
  float core = smoothstep(thick, 0.0, d);
  float baseGlow  = gauss(d, thick*6.0) * 0.18;
  float reactGlow = gauss(d, thick*6.0) * intens * 0.95;
  vec3 col = mix(cIn, cOut, uv.x);
  return col * (core*1.2 + (baseGlow + reactGlow)*0.75);
}

void main(){
  vec2 uv = vUv;
  vec3 bg = mix(u_bgBottom, u_bgTop, uv.y);

  // amplitudes
  float ampLow  = (0.35 + 2.0*u_low);
  float ampMid  = (0.25 + 1.4*u_mid);
  float ampHigh = (0.18 + 1.2*u_high);

  // use stable phases (no jitter)
  float yA = 0.50 + sin(uv.x*8.0  + u_phaseA*1.0 )*0.08*ampLow;
  float yB = 0.50 + sin(uv.x*11.0 + u_phaseB*1.27)*0.06*ampMid;
  float yC = 0.50 + sin(uv.x*14.0 + u_phaseC*1.44)*0.05*ampHigh;

  // disturbances keyed to phases (coherent, not noisy)
  yA += 0.015 * sin(uv.x*48.0 + u_phaseA*7.0  + 1.3) * clamp(u_low, 0.0, 1.0);
  yB += 0.013 * sin(uv.x*54.0 + u_phaseB*7.8  + 3.7) * clamp(u_mid, 0.0, 1.0);
  yC += 0.011 * sin(uv.x*60.0 + u_phaseC*8.6  + 5.9) * clamp(u_high,0.0, 1.0);

  float beat = pow(clamp(u_low*1.8, 0.0, 1.0), 1.6);
  float thick = u_thickness * (1.0 + 0.9*beat);

  vec3 sA = stripe(uv, yA, u_colA_in, u_colA_out, thick,      u_low);
  vec3 sB = stripe(uv, yB, u_colB_in, u_colB_out, thick*0.9,  u_mid);
  vec3 sC = stripe(uv, yC, u_colC_in, u_colC_out, thick*0.8,  u_high);

  vec3 light = sA*0.55 + sB*0.45 + sC*0.35;
  float luma = dot(light, vec3(0.299,0.587,0.114));
  vec3 reactedBg = bg + light*(0.08 + u_low*0.15) + vec3(luma)*0.12;
  float g = grain(uv*vec2(u_res.x/u_res.y,1.0)); reactedBg += g*0.015;
  vec3 col = reactedBg + light*0.85;
  gl_FragColor = vec4(col, 1.0);
}`,
      });
      scene.add(new THREE.Mesh(new THREE.PlaneGeometry(2, 2), material));

      let smoothLow = 0,
        smoothMid = 0,
        smoothHigh = 0,
        smoothEnergy = 0;

      function makeNoiseTex() {
        const s = 256;
        const c = document.createElement("canvas");
        c.width = s;
        c.height = s;
        const ctx = c.getContext("2d");
        const img = ctx.createImageData(s, s);
        const d = img.data;
        for (let i = 0; i < d.length; i += 4) {
          const v = (Math.random() * 255) | 0;
          d[i] = d[i + 1] = d[i + 2] = v;
          d[i + 3] = 255;
        }
        ctx.putImageData(img, 0, 0);
        const tex = new THREE.CanvasTexture(c);
        tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
        tex.minFilter = THREE.LinearFilter;
        tex.magFilter = THREE.LinearFilter;
        uniforms.u_noiseTex.value = tex;
        document.getElementById(
          "noise"
        ).style.backgroundImage = `url(${c.toDataURL("image/png")})`;
      }
      makeNoiseTex();

      let last = performance.now();
      let acc = 0,
        frames = 0;
      const fpsEl = document.getElementById("fps");
      function loop(now) {
        const dt = (now - last) / 1000;
        last = now;
        uniforms.u_time.value += dt;
        frames++;
        acc += dt;
        if (analyser) {
          analyser.getByteFrequencyData(freqData);
          let low = 0,
            mid = 0,
            high = 0;
          for (let i = 0; i < freqData.length; i++) {
            const f = (i * sampleRate) / FFT_SIZE;
            const v = freqData[i] / 255;
            if (f < 200) low += v;
            else if (f < 2000) mid += v;
            else high += v;
          }
          // Normalize
          const nLow = Math.min(1.0, low / 35);
          const nMid = Math.min(1.0, mid / 160);
          const nHigh = Math.min(1.0, high / 160);

          // Exponential smoothing to kill jitter
          const a = 0.12; // smoothing factor
          smoothLow = smoothLow + a * (nLow - smoothLow);
          smoothMid = smoothMid + a * (nMid - smoothMid);
          smoothHigh = smoothHigh + a * (nHigh - smoothHigh);

          uniforms.u_low.value = smoothLow;
          uniforms.u_mid.value = smoothMid;
          uniforms.u_high.value = smoothHigh;

          // Smoothed overall energy
          const rawEnergy = Math.min(
            1,
            0.6 * smoothLow + 0.3 * smoothMid + 0.1 * smoothHigh
          );
          const ae = 0.1;
          smoothEnergy = smoothEnergy + ae * (rawEnergy - smoothEnergy);

          // DISTINCT speeds per line: base speed + energy boost
          const baseA = 0.22,
            baseB = 0.28,
            baseC = 0.34;
          const boostA = 1.2,
            boostB = 1.5,
            boostC = 1.8;

          uniforms.u_phaseA.value += dt * (baseA + boostA * smoothEnergy);
          uniforms.u_phaseB.value += dt * (baseB + boostB * smoothEnergy);
          uniforms.u_phaseC.value += dt * (baseC + boostC * smoothEnergy);

          // UI reflection intensity
          const intensity = 0.05 + smoothLow * 0.9 + smoothHigh * 0.35;
          document.documentElement.style.setProperty(
            "--light-intensity",
            Math.min(1, intensity).toFixed(3)
          );
        }
        if (acc >= 0.25) {
          const fps = Math.round(frames / acc);
          fpsEl.textContent = `FPS: ${fps}`;
          frames = 0;
          acc = 0;
        }
        renderer.render(scene, camera);
        requestAnimationFrame(loop);
      }
      requestAnimationFrame(loop);

      addEventListener("resize", () => {
        renderer.setSize(innerWidth, innerHeight);
        uniforms.u_res.value.set(innerWidth, innerHeight);
      });

      const btn = document.getElementById("playBtn");
      btn.onclick = async () => {
        setupAudio();
        if (audioCtx.state === "suspended") await audioCtx.resume();
        if (!isPlaying) {
          audioEl.play();
          isPlaying = true;
          btn.textContent = "Stop";
        } else {
          audioEl.pause();
          isPlaying = false;
          btn.textContent = "Play";
        }
      };

      const cursor = document.getElementById("cursor");
      addEventListener("mousemove", (e) => {
        cursor.style.transform = `translate(${e.clientX}px,${e.clientY}px)`;
        const target = e.target.closest("button, .btn");
        if (target) cursor.classList.add("snap");
        else cursor.classList.remove("snap");
      });
    </script>
  </body>
</html>
