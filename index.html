<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Where Silence Shapes Sound — audiovisual piece</title>
    <!-- DO NOT TOUCH FONTS (kept exactly) -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Vina+Sans&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --light-intensity: 0.1;
      }
      html,
      body {
        margin: 0;
        height: 100%;
        overflow: hidden;
        background: #14100b;
        color: #efe7d6;
        cursor: none;
      }

      canvas#gl {
        position: fixed;
        inset: 0;
        width: 100%;
        height: 100%;
        display: block;
        pointer-events: none;
      }

      .noise-overlay {
        position: fixed;
        inset: -25% -25%;
        width: 150%;
        height: 150%;
        background-size: 180px 180px;
        opacity: 0.18;
        mix-blend-mode: soft-light;
        pointer-events: none;
        z-index: 9;
        filter: contrast(110%) brightness(98%);
      }

      .overlay {
        position: fixed;
        inset: 0;
        display: grid;
        place-items: center;
        text-align: center;
        z-index: 20;
        pointer-events: none;
      }
      .overlay .caption {
        font-family: "Bodoni Moda", serif;
        font-style: italic;
        letter-spacing: 0.06em;
        font-size: 1rem;
        opacity: 0.75;
      }
      .overlay .quote {
        font-family: "Vina Sans", system-ui, -apple-system, sans-serif;
        font-weight: 900;
        text-transform: uppercase;
        font-size: clamp(3rem, 9vw, 8rem);
        letter-spacing: 0.02em;
        color: rgba(255, 255, 255, 0.75);
        -webkit-text-stroke: 1px rgba(255, 255, 255, 0.95);
      }
      .overlay .attributions {
        font-family: "Bodoni Moda", serif;
        font-style: italic;
        opacity: 0.75;
      }

      .controls {
        position: fixed;
        top: 14px;
        left: 14px;
        z-index: 30;
        pointer-events: auto;
      }
      .btn {
        padding: 8px 16px;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        background: rgba(20, 20, 20, 0.35);
        color: #fff;
        font-weight: 500;
        cursor: pointer;
        backdrop-filter: blur(8px) saturate(120%);
        font-size: 0.85rem;
        opacity: 0.7;
        transition: opacity 0.2s ease;
      }
      .btn:hover {
        opacity: 1;
      }

      .fps {
        position: fixed;
        top: 14px;
        right: 14px;
        padding: 6px 12px;
        border-radius: 999px;
        z-index: 30;
        font-family: ui-monospace, monospace;
        font-size: 12px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        background: rgba(20, 20, 20, 0.35);
        backdrop-filter: blur(8px) saturate(120%);
        opacity: 0.6;
        transition: opacity 0.2s ease;
      }
      .fps:hover {
        opacity: 1;
      }

      .cursor {
        position: fixed;
        width: 14px;
        height: 14px;
        border-radius: 50%;
        background: rgba(255, 215, 120, 0.95);
        box-shadow: 0 0 20px rgba(255, 220, 120, 0.9);
        transform: translate(-50%, -50%);
        z-index: 100;
        pointer-events: none;
        transition: filter 0.15s ease;
      }
      .cursor.snap {
        filter: brightness(1.6);
      }
    </style>
  </head>
  <body>
    <canvas id="gl"></canvas>
    <div class="noise-overlay" id="noise"></div>

    <div class="overlay">
      <div>
        <div class="caption">Sight tuned to bass and breath</div>
        <div class="quote">Where Silence Shapes Sound</div>
        <div class="attributions">Music by KOSIKK</div>
      </div>
    </div>

    <div class="controls"><button class="btn" id="playBtn">Play</button></div>
    <div class="fps" id="fps">FPS: —</div>
    <div class="cursor" id="cursor"></div>

    <script type="module">
      import * as THREE from "https://unpkg.com/three@0.160.1/build/three.module.js";

      // --- AUDIO ---
      const AUDIO_URL = "https://assets.codepen.io/7558/kosikk-slow-motion.ogg";
      let audioCtx,
        audioEl,
        analyser,
        isPlaying = false,
        sourceNode;
      const FFT_SIZE = 1024;
      let dataArray;
      function setupAudio() {
        if (audioCtx) return;
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioCtx.createAnalyser();
        analyser.fftSize = FFT_SIZE;
        dataArray = new Uint8Array(analyser.frequencyBinCount);
        audioEl = new Audio();
        audioEl.crossOrigin = "anonymous";
        audioEl.src = AUDIO_URL;
        audioEl.loop = true;
        sourceNode = audioCtx.createMediaElementSource(audioEl);
        sourceNode.connect(analyser);
        analyser.connect(audioCtx.destination);
      }

      // --- ANALYSIS (ported almost 1:1 from the reference) ---
      let lowFreq = 0,
        midFreq = 0,
        highFreq = 0; // smoothed 0..1
      let kickDetected = false,
        kickEnergy = 0,
        kickImpact = 0,
        lastKickTime = 0;
      const kickDecay = 0.8,
        kickThreshold = 0.05;
      const historyLength = 4;
      const bandEnergies = Array(8).fill(0);
      const bandHistories = Array(8)
        .fill(0)
        .map(() => []);
      const bands = [
        [1, 4],
        [4, 9],
        [9, 20],
        [20, 40],
        [40, 80],
        [80, 160],
        [160, 300],
        [300, 500],
      ];

      function getWeightedAverage(array) {
        if (!array.length) return 0;
        let sum = 0,
          w = 0,
          maxv = 0;
        const emph = 1.5;
        for (let i = 0; i < array.length; i++) {
          const v = array[i] / 255;
          maxv = Math.max(maxv, v);
          sum += Math.pow(v, emph);
          w++;
        }
        const avg = sum / w;
        return avg * 0.7 + maxv * 0.3;
      }

      function updateFrequencies() {
        if (!isPlaying || !analyser) return;
        analyser.getByteFrequencyData(dataArray);
        for (let i = 0; i < bands.length; i++) {
          const [a, b] = bands[i];
          const slice = dataArray.slice(a, Math.min(b, dataArray.length));
          const e = getWeightedAverage(slice);
          bandEnergies[i] = e;
          bandHistories[i].unshift(e);
          if (bandHistories[i].length > historyLength) bandHistories[i].pop();
        }
        const kickAvg = bandEnergies[1];
        const kickHist = bandHistories[1];
        const recent =
          kickHist.slice(1).reduce((s, v) => s + v, 0) /
          (kickHist.length - 1 || 1);
        const jump = kickAvg - recent;
        const now = performance.now();
        const newKick =
          jump > kickThreshold * 1.2 &&
          kickAvg > 0.15 &&
          (!kickDetected || now - lastKickTime > 150);
        if (newKick) {
          kickDetected = true;
          kickEnergy = Math.min(1.0, kickAvg * 2.0);
          kickImpact = 10;
          lastKickTime = now;
        } else {
          kickEnergy *= kickDecay;
          if (kickEnergy < 0.05) kickDetected = false;
          if (kickImpact > 0) kickImpact--;
        }

        const combinedBass = (bandEnergies[1] * 1.2 + bandEnergies[2]) / 2.2;
        const combinedMid = (bandEnergies[3] + bandEnergies[4]) / 2.0;
        const combinedHigh =
          (bandEnergies[5] + bandEnergies[6] + bandEnergies[7]) / 3.0;
        const smooth = (prev, tgt, atk, dec) =>
          prev + (tgt > prev ? atk : dec) * (tgt - prev);
        lowFreq = smooth(lowFreq, combinedBass, 0.9, 0.12);
        midFreq = smooth(midFreq, combinedMid, 0.4, 0.2);
        highFreq = smooth(highFreq, combinedHigh, 0.5, 0.2);
        lowFreq = Math.max(lowFreq, kickEnergy * 0.6);

        // bounce value
        let bounce = 0.0;
        if (kickImpact > 0) bounce = Math.pow(kickImpact / 10, 0.6) * 0.03;
        bounce += kickEnergy * 0.025;
        uniforms.bounceEffect.value = bounce;
        // push to uniforms
        uniforms.lowFreq.value = lowFreq;
        uniforms.midFreq.value = midFreq;
        uniforms.highFreq.value = highFreq;
        uniforms.kickEnergy.value = kickEnergy;
      }

      // --- THREE + SHADER (directly adapted) ---
      const renderer = new THREE.WebGLRenderer({
        canvas: document.getElementById("gl"),
        antialias: true,
      });
      renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
      renderer.setSize(innerWidth, innerHeight);
      const scene = new THREE.Scene();
      const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

      const vertexShader = `varying vec2 vUv; void main(){ vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0); }`;
      const fragmentShader = `
precision highp float; varying vec2 vUv;
uniform vec2 iResolution; uniform float iTime; uniform vec2 iMouse;
uniform float lowFreq, midFreq, highFreq; uniform bool isPlaying; uniform float transitionFactor; uniform float lineStraightness; uniform float idleAnimation; uniform float idleWaveHeight;
uniform float kickEnergy; uniform float beatPhase; uniform float bounceEffect;
uniform float baseSpeed; uniform float idleSpeed; uniform float bassReactivity; uniform float midReactivity; uniform float highReactivity; uniform float kickReactivity; uniform float bounceIntensity; uniform float waveIntensity; uniform float waveComplexity; uniform float rippleIntensity; uniform float lineThickness;
uniform bool enableGrain; uniform float grainIntensity; uniform float grainSpeed; uniform float grainMean; uniform float grainVariance; uniform int grainBlendMode;
uniform vec3 bgColorDown, bgColorUp, color1In, color1Out, color2In, color2Out, color3In, color3Out;

float squared(float v){ return v*v; }
float smootherstep(float e0,float e1,float x){ float t=clamp((x-e0)/(e1-e0),0.0,1.0); return t*t*t*(t*(t*6.0-15.0)+10.0);} 
vec3 channel_mix(vec3 a, vec3 b, vec3 w){ return vec3(mix(a.r,b.r,w.r), mix(a.g,b.g,w.g), mix(a.b,b.b,w.b)); }
float gaussian(float z,float u,float o){ return (1.0/(o*sqrt(2.0*3.1415)))*exp(-(((z-u)*(z-u))/(2.0*(o*o)))); }
vec3 screen(vec3 a, vec3 b, float w){ return mix(a, vec3(1.0)-(vec3(1.0)-a)*(vec3(1.0)-b), w); }
vec3 overlay(vec3 a, vec3 b, float w){ return mix(a, channel_mix(2.0*a*b, vec3(1.0)-2.0*(vec3(1.0)-a)*(vec3(1.0)-b), step(vec3(0.5), a)), w); }
vec3 soft_light(vec3 a, vec3 b, float w){ return mix(a, pow(a, pow(vec3(2.0), 2.0*(vec3(0.5)-b))), w); }
vec3 applyGrain(vec3 color, vec2 uv){ if(!enableGrain) return color; float t=iTime*grainSpeed; float seed=dot(uv, vec2(12.9898,78.233)); float noise=fract(sin(seed)*43758.5453+t); noise=gaussian(noise, grainMean, grainVariance*grainVariance); vec3 g=vec3(noise)*(1.0-color); if(grainBlendMode==0){ color+=g*grainIntensity; } else if(grainBlendMode==1){ color=screen(color,g,grainIntensity);} else if(grainBlendMode==2){ color=overlay(color,g,grainIntensity);} else if(grainBlendMode==3){ color=soft_light(color,g,grainIntensity);} else if(grainBlendMode==4){ color=max(color, g*grainIntensity);} return color; }
float kickRipple(vec2 uv,float energy,float time){ float dist=distance(uv, vec2(0.5)); float width=0.05; float speed=1.2; float r1=smootherstep(energy*speed*time-width, energy*speed*time, dist); r1*=smootherstep(dist, dist+width, energy*speed*time+width); float r2=smootherstep(energy*speed*(time-0.2)-width, energy*speed*(time-0.2), dist); r2*=smootherstep(dist, dist+width, energy*speed*(time-0.2)+width); return (r1 + r2*0.5) * energy * 0.7; }

void main(){ vec2 p = vUv; vec3 bgCol = mix(bgColorDown, bgColorUp, clamp(p.y*2.0,0.0,1.0));
  float speed = mix(idleSpeed, baseSpeed, transitionFactor);
  float ballVisibility = mix(0.8, 0.2, transitionFactor);
  float straightnessFactor = mix(1.0, lineStraightness, transitionFactor);
  float idleWave = idleWaveHeight * sin(p.x*5.0 + idleAnimation*0.2);
  float bassPulse = squared(lowFreq) * bassReactivity * transitionFactor; float midPulse=squared(midFreq)*midReactivity*transitionFactor; float highPulse=squared(highFreq)*highReactivity*transitionFactor; float kickPulse=squared(kickEnergy)*kickReactivity*1.5*transitionFactor; float bounce=bounceEffect*bounceIntensity*transitionFactor;
  float curveIntensity = mix(idleWaveHeight, 0.05 + waveIntensity*(bassPulse + kickPulse*0.7), transitionFactor); float curveSpeed = speed;
  float curve = curveIntensity * sin((6.25*p.x) + (curveSpeed*iTime));
  float ripple = rippleIntensity * kickRipple(p, kickEnergy, mod(iTime,10.0)) * transitionFactor;
  float audioWave = mix(0.0, (0.1*sin(p.x*20.0*waveComplexity)*bassPulse + 0.08*sin(p.x*30.0*waveComplexity)*midPulse + 0.05*sin(p.x*50.0*waveComplexity)*highPulse)/straightnessFactor, transitionFactor);

  float lineAFreq = 40.0*waveComplexity + 80.0*bassPulse + 90.0*kickPulse; float lineASpeed = 1.5*speed + 6.0*bassPulse + 6.0*kickPulse;
  float lineAWave = mix(idleWave, (0.01 + 0.05*bassPulse + 0.1*kickPulse)/straightnessFactor, transitionFactor);
  float kickWaveEffect = 0.0; if(kickEnergy>0.1){ kickWaveEffect = kickEnergy * 0.3 * sin(15.0*(p.x - iTime*0.5)) * transitionFactor; }
  float lineAOffset = bassPulse*0.3*sin(p.x*10.0 - iTime*2.0) + kickWaveEffect*0.7;
  float lineAY = 0.5; float lineAActive = lineAY + curve + audioWave + lineAWave*sin((lineAFreq*p.x)+(-lineASpeed*iTime)) + lineAOffset - bounce; float lineAIdle = lineAY + idleWave; float lineAAnim = mix(lineAIdle, lineAActive, transitionFactor);
  float lineAThick = lineThickness * (1.0 + bassPulse*0.4 + kickPulse*0.8);
  float lineADist = distance(p.y, lineAAnim) * (2.0 / lineAThick); float lineAShape = smootherstep(1.0 - clamp(lineADist,0.0,1.0), 1.0, 0.99);
  vec3 kickColor = vec3(1.0,0.7,0.3);
  vec3 enhanced1In = mix(color1In, kickColor, kickEnergy * 0.6 * transitionFactor); vec3 enhanced1Out = mix(color1Out, vec3(1.0,0.5,0.0), kickEnergy * 0.4 * transitionFactor);
  vec3 lineACol = (1.0 - lineAShape) * vec3(mix(enhanced1In, enhanced1Out, lineAShape));

  float lineBFreq = 50.0*waveComplexity + 100.0*midPulse; float lineBSpeed = 2.0*speed + 8.0*midPulse; float lineBWave = mix(idleWave*0.8, (0.01+0.05*midPulse)/straightnessFactor, transitionFactor);
  float lineBOffset = midPulse*0.2*sin(p.x*15.0 - iTime*1.5) + kickEnergy*0.1*sin(p.x*25.0 - iTime*3.0) * transitionFactor; float lineBY=0.5; float lineBActive = lineBY + curve - audioWave + lineBWave * sin((lineBFreq*p.x) + (lineBSpeed*iTime)) * sin(lineBSpeed*iTime) + lineBOffset - bounce*0.5; float lineBIdle = lineBY + idleWave*0.8; float lineBAnim = mix(lineBIdle, lineBActive, transitionFactor);
  float lineBThick = lineThickness * (1.0 + midPulse*0.3 + kickEnergy*0.3*transitionFactor);
  float lineBDist = distance(p.y, lineBAnim) * (2.0 / lineBThick); float lineBShape = smootherstep(1.0 - clamp(lineBDist,0.0,1.0), 1.0, 0.99);
  vec3 enhanced2In = mix(color2In, vec3(1.0,0.5,0.5), kickEnergy*0.3*transitionFactor); vec3 lineBCol = (1.0 - lineBShape) * vec3(mix(enhanced2In, color2Out, lineBShape));

  float lineCFreq = 60.0*waveComplexity + 120.0*highPulse; float lineCSpeed = 2.5*speed + 10.0*highPulse; float lineCWave = mix(idleWave*1.2, (0.01+0.05*highPulse)/straightnessFactor, transitionFactor); float lineCOffset = highPulse*0.15*sin(p.x*20.0 - iTime*1.0);
  float lineCY=0.5; float lineCActive = lineCY + curve*0.7 - audioWave*0.5 + lineCWave * sin((lineCFreq*p.x) + (lineCSpeed*iTime)) * sin(lineCSpeed*(iTime+0.1)) + lineCOffset - bounce*0.3; float lineCIdle = lineCY + idleWave*1.2; float lineCAnim = mix(lineCIdle, lineCActive, transitionFactor);
  float lineCThick = lineThickness * (1.0 + highPulse*0.2 + kickEnergy*0.1*transitionFactor);
  float lineCDist = distance(p.y, lineCAnim) * (2.0 / lineCThick); float lineCShape = smootherstep(1.0 - clamp(lineCDist,0.0,1.0), 1.0, 0.99);
  vec3 lineCCol = (1.0 - lineCShape) * vec3(mix(color3In, color3Out, lineCShape));

  float ballASize = 0.5 + 0.4*bassPulse + kickEnergy*1.2*transitionFactor; float ballAX = 0.2 + 0.1*sin(iTime*0.2*speed)*midPulse; float ballAD = distance(p, vec2(ballAX, lineAAnim)); float ballAShape = smootherstep(1.0 - clamp(ballAD*ballASize,0.0,1.0), 1.0, 0.99); vec3 ballACol = (1.0 - ballAShape) * vec3(mix(enhanced1In, enhanced1Out, ballAShape)) * mix(1.0, ballVisibility, transitionFactor);
  float ballBSize = 0.5 + 0.4*highPulse + kickEnergy*0.3*transitionFactor; float ballBX = 0.8 - 0.1*sin(iTime*0.3*speed)*midPulse; float ballBD = distance(p, vec2(ballBX, lineBAnim)); float ballBShape = smootherstep(1.0 - clamp(ballBD*ballBSize,0.0,1.0), 1.0, 0.99); vec3 ballBCol = (1.0 - ballBShape) * vec3(mix(enhanced2In, color2Out, ballBShape)) * mix(1.0, ballVisibility, transitionFactor);
  float ballCSize = 0.5 + 0.4*highPulse + kickEnergy*0.1*transitionFactor; float ballCX = 0.5 + 0.15*sin(iTime*0.4*speed)*highPulse; float ballCD = distance(p, vec2(ballCX, lineCAnim)); float ballCShape = smootherstep(1.0 - clamp(ballCD*ballCSize,0.0,1.0), 1.0, 0.99); vec3 ballCCol = (1.0 - ballCShape) * vec3(mix(color3In, color3Out, ballCShape)) * mix(1.0, ballVisibility, transitionFactor);

  bgCol = mix(bgCol, mix(bgCol, vec3(1.0), 0.3), kickEnergy * 0.5 * transitionFactor); // slightly stronger than ref for more impact
  vec3 rippleCol = vec3(1.0, 0.8, 0.4) * ripple * transitionFactor;
  vec3 fcolor = bgCol + lineACol + lineBCol + lineCCol + ballACol + ballBCol + ballCCol + rippleCol;
  fcolor = applyGrain(fcolor, p);
  gl_FragColor = vec4(fcolor, 1.0);
}
      `;

      const uniforms = {
        iResolution: { value: new THREE.Vector2(innerWidth, innerHeight) },
        iTime: { value: 0 },
        iMouse: { value: new THREE.Vector2(0.5, 0.5) },
        lowFreq: { value: 0 },
        midFreq: { value: 0 },
        highFreq: { value: 0 },
        isPlaying: { value: false },
        transitionFactor: { value: 0 },
        lineStraightness: { value: 2.53 },
        idleAnimation: { value: 0 },
        idleWaveHeight: { value: 0.01 },
        kickEnergy: { value: 0 },
        beatPhase: { value: 0 },
        bounceEffect: { value: 0 },
        baseSpeed: { value: 1.0 },
        idleSpeed: { value: 0.1 },
        bassReactivity: { value: 0.4 },
        midReactivity: { value: 0.5 },
        highReactivity: { value: 0.4 },
        kickReactivity: { value: 0.6 },
        bounceIntensity: { value: 0.15 },
        waveIntensity: { value: 0.08 },
        waveComplexity: { value: 2.2 },
        rippleIntensity: { value: 0.25 },
        lineThickness: { value: 1.9 },
        enableGrain: { value: true },
        grainIntensity: { value: 0.085 },
        grainSpeed: { value: 2.0 },
        grainMean: { value: 0.0 },
        grainVariance: { value: 0.5 },
        grainBlendMode: { value: 0 },
        bgColorDown: { value: new THREE.Vector3(40 / 255, 20 / 255, 10 / 255) },
        bgColorUp: { value: new THREE.Vector3(20 / 255, 10 / 255, 5 / 255) },
        color1In: { value: new THREE.Vector3(255 / 255, 200 / 255, 0 / 255) },
        color1Out: { value: new THREE.Vector3(255 / 255, 100 / 255, 0 / 255) },
        color2In: { value: new THREE.Vector3(255 / 255, 100 / 255, 100 / 255) },
        color2Out: { value: new THREE.Vector3(200 / 255, 50 / 255, 50 / 255) },
        color3In: { value: new THREE.Vector3(255 / 255, 150 / 255, 50 / 255) },
        color3Out: { value: new THREE.Vector3(200 / 255, 100 / 255, 0 / 255) },
      };

      const material = new THREE.ShaderMaterial({
        vertexShader,
        fragmentShader,
        uniforms,
        transparent: false,
      });
      const mesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), material);
      scene.add(mesh);

      // --- NOISE TEXTURE for CSS overlay (visual match) ---
      function makeNoiseTex() {
        const s = 256;
        const c = document.createElement("canvas");
        c.width = s;
        c.height = s;
        const ctx = c.getContext("2d");
        const img = ctx.createImageData(s, s);
        const d = img.data;
        for (let i = 0; i < d.length; i += 4) {
          const v = (Math.random() * 255) | 0;
          d[i] = d[i + 1] = d[i + 2] = v;
          d[i + 3] = 255;
        }
        ctx.putImageData(img, 0, 0);
        document.getElementById(
          "noise"
        ).style.backgroundImage = `url(${c.toDataURL("image/png")})`;
      }
      makeNoiseTex();

      // --- LOOP ---
      let last = performance.now(),
        frames = 0,
        acc = 0;
      const fpsEl = document.getElementById("fps");
      let transition = 0;
      function animate(now) {
        requestAnimationFrame(animate);
        const dt = (now - last) / 1000;
        last = now;
        uniforms.iTime.value += 0.01;
        uniforms.idleAnimation.value += 0.01;
        updateFrequencies();
        // smooth transition
        const rate = 0.03;
        if (isPlaying && transition < 1.0) {
          transition = Math.min(transition + rate, 1.0);
        } else if (!isPlaying && transition > 0.0) {
          transition = Math.max(transition - rate, 0.0);
          if (transition === 0) {
            lowFreq = midFreq = highFreq = kickEnergy = 0;
            uniforms.lowFreq.value =
              uniforms.midFreq.value =
              uniforms.highFreq.value =
              uniforms.kickEnergy.value =
                0;
            uniforms.bounceEffect.value = 0;
          }
        }
        uniforms.transitionFactor.value = transition;
        uniforms.isPlaying.value = isPlaying;
        // mouse-driven
        renderer.render(scene, camera);
        acc += dt;
        frames++;
        if (acc >= 0.25) {
          fpsEl.textContent = `FPS: ${Math.round(frames / acc)}`;
          frames = 0;
          acc = 0;
        }
      }
      requestAnimationFrame(animate);

      // --- EVENTS ---
      addEventListener("resize", () => {
        renderer.setSize(innerWidth, innerHeight);
        uniforms.iResolution.value.set(innerWidth, innerHeight);
      });
      addEventListener("mousemove", (e) => {
        uniforms.iMouse.value.set(e.clientX, e.clientY);
        const cursor = document.getElementById("cursor");
        cursor.style.transform = `translate(${e.clientX}px,${e.clientY}px)`;
        const t = e.target.closest("button,.btn");
        if (t) cursor.classList.add("snap");
        else cursor.classList.remove("snap");
      });

      const btn = document.getElementById("playBtn");
      btn.onclick = async () => {
        setupAudio();
        if (audioCtx.state === "suspended") await audioCtx.resume();
        if (!isPlaying) {
          audioEl.play();
          isPlaying = true;
          btn.textContent = "Stop";
        } else {
          audioEl.pause();
          isPlaying = false;
          btn.textContent = "Play";
        }
      };
    </script>
  </body>
</html>
