<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Where Silence Shapes Sound â€” audiovisual piece</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Vina+Sans&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --bg-0: #0b0b10;
        --bg-1: #0e0c14;
        --text-strong: #ffffff;
        --text-muted: #c9ced3;
        --glass-bg: rgba(18, 20, 22, 0.5);
        --btn-bg: rgba(10, 12, 14, 0.72);
        --glass-brd: rgba(255, 255, 255, 0.12);
        --frost-pad: 14px;
        --frost-radius: 22px;
      }

      html,
      body {
        margin: 0;
        height: 100%;
        overflow: hidden;
        background: radial-gradient(
            900px 700px at 20% 18%,
            var(--bg-1),
            transparent 60%
          ),
          radial-gradient(900px 700px at 80% 82%, var(--bg-1), transparent 55%),
          var(--bg-0);
        color: var(--text-strong);
        cursor: none !important;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        text-rendering: optimizeLegibility;
      }

      canvas#gl {
        position: fixed;
        inset: 0;
        width: 100%;
        height: 100%;
        display: block;
        pointer-events: none;
      }

      .noise-overlay {
        position: fixed;
        inset: -25% -25%;
        width: 150%;
        height: 150%;
        background-size: 180px 180px;
        opacity: 0.1;
        mix-blend-mode: soft-light;
        pointer-events: none;
        z-index: 9;
        filter: contrast(104%) brightness(100%);
      }

      .overlay {
        position: fixed;
        inset: 0;
        z-index: 20;
        pointer-events: none;
      }
      .overlay-slot {
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
        display: inline-block;
        width: max-content;
        text-align: center;
        padding: 0.25rem 0;
      }
      .overlay-slot.top {
        top: 12vh;
      }
      .overlay-slot.bottom {
        bottom: 14vh;
      }

      .overlay-slot::before {
        content: "";
        position: absolute;
        inset: -3% -2%;
        z-index: -1;
        border-radius: 28px;
        background: radial-gradient(
          50% 60% at 50% 50%,
          rgba(6, 8, 10, 0.9),
          rgba(6, 8, 10, 0.42) 60%,
          transparent 85%
        );
        filter: blur(8px);
      }

      .caption,
      .quote,
      .attributions {
        text-shadow: 0 1px 1px rgba(0, 0, 0, 0.35);
      }
      .caption {
        font-family: "Bodoni Moda", serif;
        font-style: italic;
        letter-spacing: 0.08em;
        font-size: clamp(0.95rem, 1.2vw, 1.1rem);
        color: var(--text-muted);
        opacity: 0.96;
      }
      .quote {
        font-family: "Vina Sans", system-ui, -apple-system, sans-serif;
        font-weight: 800;
        text-transform: uppercase;
        letter-spacing: 0.005em;
        line-height: 0.86;
        color: var(--text-strong);
        -webkit-text-stroke: 0.35px rgba(0, 0, 0, 0.25);
        text-shadow: 0 0 0.6px rgba(0, 0, 0, 0.3),
          0 2px 10px rgba(0, 0, 0, 0.25);
      }
      #quoteTop {
        font-size: clamp(3rem, 9vw, 7.1rem);
      }
      #quoteBottom {
        font-size: clamp(3rem, 9vw, 7.9rem);
      }
      .attributions {
        font-family: "Bodoni Moda", serif;
        font-style: italic;
        color: var(--text-muted);
        opacity: 0.96;
        margin-top: 0.5rem;
      }
      .attributions a,
      .attributions a:link,
      .attributions a:visited,
      .attributions a:hover,
      .attributions a:active,
      .attributions a:focus {
        color: inherit;
        text-decoration: underline;
      }
      .attributions a {
        pointer-events: auto;
        cursor: none !important;
      }
      .attributions a:hover,
      .attributions a:focus {
        font-weight: 600;
      }

      .controls {
        position: fixed;
        left: 16px;
        bottom: 16px;
        z-index: 30;
        display: flex;
        gap: 10px;
        align-items: center;
        pointer-events: auto;
      }
      .menu-panel {
        position: relative;
        display: inline-block;
        padding: var(--frost-pad);
        border-radius: var(--frost-radius);
        z-index: 0;
        backdrop-filter: blur(12px) saturate(120%);
        -webkit-backdrop-filter: blur(12px) saturate(120%);
        isolation: isolate;
      }
      .menu-panel::before {
        content: "";
        position: absolute;
        inset: 0;
        border-radius: inherit;
        pointer-events: none;
        background-color: rgba(10, 12, 14, 0.5);
        background-image: radial-gradient(
          90% 90% at 50% 50%,
          rgba(10, 12, 14, 0.6) 0%,
          rgba(10, 12, 14, 0.52) 65%,
          rgba(10, 12, 14, 0.4) 82%,
          rgba(10, 12, 14, 0) 100%
        );
        backdrop-filter: blur(12px) saturate(120%);
        -webkit-backdrop-filter: blur(12px) saturate(120%);
        z-index: -1;
      }
      @supports not (
        (backdrop-filter: blur(2px)) or (-webkit-backdrop-filter: blur(2px))
      ) {
        .menu-panel::before {
          background-color: rgba(10, 12, 14, 0.78);
          background-image: radial-gradient(
            90% 90% at 50% 50%,
            rgba(10, 12, 14, 0.82) 0%,
            rgba(10, 12, 14, 0.78) 65%,
            rgba(10, 12, 14, 0.66) 82%,
            rgba(10, 12, 14, 0) 100%
          );
        }
      }
      .color-menu {
        --menu-icon-size: 44px;
        --ease-out: cubic-bezier(0.22, 1, 0.36, 1);
        --radius-start: 28px;
        --radius-open: 18px;
        --items-duration: 260ms;
        --width-duration: 260ms;
        --child-stagger-1: 120ms;
        --child-stagger-2: 180ms;
        --label-cx: 50%;
        --label-cy: 50%;
        position: relative;
        display: flex;
        align-items: flex-end;
        gap: 10px;
      }
      .btn.btn-icon {
        width: var(--menu-icon-size);
        height: var(--menu-icon-size);
        min-width: 44px;
        min-height: 44px;
        padding: 0;
        border-radius: 999px;
        position: relative;
      }
      .btn.btn-icon .icon {
        position: absolute;
        left: 50%;
        top: 50%;
        width: 22px;
        height: 22px;
        transform: translate(-50%, -50%);
        opacity: 0.98;
        transition: opacity 200ms var(--ease-out),
          transform 260ms var(--ease-out);
        will-change: transform, opacity;
      }
      .btn.btn-icon .close-icon {
        opacity: 0;
        transform: translate(-50%, -50%) rotate(-90deg) scale(0.9);
      }
      .color-menu.open .btn.btn-icon .hamburger-icon {
        opacity: 0;
        transform: translate(-50%, -50%) rotate(90deg) scale(0.9);
      }
      .color-menu.open .btn.btn-icon .close-icon {
        opacity: 1;
        transform: translate(-50%, -50%) rotate(0deg) scale(1);
      }
      .menu-items {
        position: absolute;
        left: 0;
        bottom: calc(100% + 10px);
        overflow: visible;
        opacity: 0;
        pointer-events: none;
        will-change: opacity;
        transition: opacity var(--items-duration) var(--ease-out);
      }
      .color-menu.open .menu-items {
        opacity: 1;
        pointer-events: auto;
      }
      .menu-width {
        display: grid;
        gap: 10px;
        width: max-content;
      }
      .color-menu.anim-opening .menu-items {
        transition-delay: 0ms;
      }
      .color-menu.anim-opening .menu-width {
        transition-delay: 120ms;
      }
      .color-menu.anim-closing .menu-width {
        transition-delay: 0ms;
      }
      .color-menu.anim-closing .menu-items {
        transition-delay: 120ms;
      }
      .menu-width > .btn {
        opacity: 0;
        transform: translateY(8px) scale(0.985);
        will-change: transform, opacity;
        transition: transform 260ms cubic-bezier(0.16, 1, 0.3, 1),
          opacity 200ms var(--ease-out);
      }
      .color-menu.open .menu-width > .btn {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
      .color-menu.anim-opening .menu-width > .btn {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
      .color-menu.anim-opening .menu-width > .btn:nth-child(1) {
        transition-delay: var(--child-stagger-1);
      }
      .color-menu.anim-opening .menu-width > .btn:nth-child(2) {
        transition-delay: var(--child-stagger-2);
      }
      .color-menu.anim-closing .menu-width > .btn {
        transition-delay: 0ms;
      }
      .menu-width > .btn .btn-label {
        display: inline-block;
        opacity: 1;
        transform: none;
        clip-path: none;
        transition: none !important;
      }
      .btn {
        padding: 10px 18px;
        border-radius: 999px;
        border: 1px solid var(--glass-brd);
        background: var(--btn-bg);
        color: var(--text-strong);
        cursor: none !important;
        font-weight: 600;
        font-size: 0.9rem;
        letter-spacing: 0.02em;
        backdrop-filter: blur(10px) saturate(120%);
        -webkit-backdrop-filter: blur(10px) saturate(120%);
        -webkit-background-clip: padding-box;
        background-clip: padding-box;
        z-index: 0;
        transform: translateZ(0);
        -webkit-transform: translateZ(0);
        backface-visibility: hidden;
        -webkit-backface-visibility: hidden;
        opacity: 0.96;
        --magnet-x: 0px;
        --magnet-y: 0px;
        --hover-ty: 0px;
        --press-scale: 1;
        transform: translate(var(--magnet-x), var(--magnet-y))
          translateY(var(--hover-ty)) scale(var(--press-scale));
        transition: opacity 0.2s ease, transform 0.12s ease,
          box-shadow 0.2s ease;
        box-shadow: 0 6px 18px rgba(0, 0, 0, 0.25),
          inset 0 0 0 1px rgba(255, 255, 255, 0.04);
        position: relative;
        overflow: hidden;
      }
      .btn:hover {
        opacity: 1;
        --hover-ty: -1px;
      }
      .btn:active {
        --press-scale: 0.96;
        --hover-ty: 0px;
      }

      .fps {
        position: fixed;
        right: 16px;
        bottom: 16px;
        z-index: 30;
        padding: 6px 12px;
        border-radius: 999px;
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas,
          "Liberation Mono", monospace;
        font-size: 12px;
        border: 1px solid var(--glass-brd);
        background: var(--glass-bg);
        color: var(--text-muted);
        backdrop-filter: blur(10px) saturate(120%);
        -webkit-backdrop-filter: blur(10px) saturate(120%);
        opacity: 0.92;
        transition: opacity 0.2s ease;
      }
      .fps:hover {
        opacity: 1;
      }

      /* Button ripple effect */
      @property --r {
        syntax: "<length>";
        initial-value: 0px;
        inherits: false;
      }
      @property --rx {
        syntax: "<length>";
        initial-value: 0px;
        inherits: false;
      }
      @property --ry {
        syntax: "<length>";
        initial-value: 0px;
        inherits: false;
      }
      .btn .ripple-in {
        position: absolute;
        left: var(--rx);
        top: var(--ry);
        border-radius: 999px;
        background: #ffffff;
        mix-blend-mode: difference;
        transform: translate(-50%, -50%) scale(0);
        pointer-events: none;
        will-change: transform, opacity;
        animation: ripple-in 220ms ease-out forwards;
      }
      @keyframes ripple-in {
        0% {
          transform: translate(-50%, -50%) scale(0);
          opacity: 0.98;
        }
        100% {
          transform: translate(-50%, -50%) scale(1);
          opacity: 0.95;
        }
      }
      .btn .ripple-out {
        position: absolute;
        inset: 0;
        background: #ffffff;
        mix-blend-mode: difference;
        pointer-events: none;
        will-change: -webkit-mask-image, mask-image;
        -webkit-mask-image: radial-gradient(
          circle at var(--rx) var(--ry),
          rgba(0, 0, 0, 0) 0 var(--r),
          rgba(0, 0, 0, 1) calc(var(--r) + 1px)
        );
        mask-image: radial-gradient(
          circle at var(--rx) var(--ry),
          rgba(0, 0, 0, 0) 0 var(--r),
          rgba(0, 0, 0, 1) calc(var(--r) + 1px)
        );
      }
      @supports not (
        (-webkit-mask-image: radial-gradient(#000 0 0)) or
          (mask-image: radial-gradient(#000 0 0))
      ) {
        .btn .ripple-out {
          -webkit-mask-image: none;
          mask-image: none;
          clip-path: circle(var(--r) at var(--rx) var(--ry));
        }
      }

      /* Cursor */
      .cursor {
        position: fixed;
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: #ffffff;
        mix-blend-mode: difference;
        box-shadow: none;
        transform: translate(-50%, -50%);
        z-index: 100;
        pointer-events: none;
        transition: filter 0.15s ease, transform 0.08s ease, width 0.12s ease,
          height 0.12s ease, border-radius 0.12s ease, box-shadow 0.12s ease,
          background 0.12s ease;
      }
      .cursor::after {
        content: "";
        position: absolute;
        inset: -8px;
        border-radius: 50%;
        border: 1px solid rgba(235, 226, 255, 0.45);
        mix-blend-mode: difference;
        transition: opacity 0.15s ease, transform 0.2s ease,
          border-color 0.12s ease, filter 0.1s ease;
        transform: translate(var(--ring-ox, 0px), var(--ring-oy, 0px));
      }
      .cursor.snap {
        filter: brightness(1.1);
        transform: translate(-50%, -50%) scale(1.06);
      }
      .cursor.btn-hover {
        border-radius: 999px;
        background: #ffffff;
        box-shadow: none;
      }
      .cursor.btn-hover::after {
        inset: -6px;
        border-radius: 999px;
        border-color: rgba(190, 170, 255, 0.6);
      }
      .cursor.text-hover {
        width: 24px;
        height: 24px;
        border-radius: 50%;
        background: #ffffff;
        box-shadow: none;
      }
      .cursor.text-hover::after {
        inset: -10px;
        border-radius: 999px;
        transform: translate(var(--ring-ox, 0px), var(--ring-oy, 0px))
          scale(1.05);
      }

      /* Beat reaction: brighten and distort the ring */
      .cursor.beat::after {
        border-color: rgba(255, 255, 255, 0.6);
        opacity: 0.98;
        filter: url(#cursorSpiky);
      }

      @media (prefers-reduced-motion: reduce) {
        .btn,
        .fps,
        .cursor,
        .menu-items,
        .menu-width,
        .menu-width > .btn,
        .menu-width > .btn .btn-label {
          transition: none;
        }
      }

      /* Backdrop-filter fallback: boost contrast when unsupported */
      @supports not (
        (backdrop-filter: blur(2px)) or (-webkit-backdrop-filter: blur(2px))
      ) {
        .btn,
        .fps {
          background: rgba(12, 14, 16, 0.84);
        }
      }

      /* Touch/coarse pointers: never show custom cursor */
      @media (hover: none), (pointer: coarse) {
        .cursor {
          display: none !important;
        }
        html,
        body,
        .btn {
          cursor: auto !important;
        }
      }
    </style>
  </head>
  <body>
    <canvas id="gl"></canvas>
    <div class="noise-overlay" id="noise"></div>

    <div class="overlay" aria-hidden="true">
      <div class="overlay-slot top" id="titleTop">
        <div class="caption" id="caption">Sight tuned to bass and breath</div>
        <div class="quote" id="quoteTop">Where Silence</div>
      </div>
      <div class="overlay-slot bottom" id="titleBottom">
        <div class="quote" id="quoteBottom">Shapes Sound</div>
        <div class="attributions" id="attrib">
          Song: Exil - Hiboky by manyfaced<br />
          Design inspired by
          <a
            href="https://codepen.io/filipz/pen/dPygJGM"
            target="_blank"
            rel="noopener noreferrer"
            >Filip Zrnzevic</a
          >'s work.
        </div>
      </div>
    </div>

    <div class="controls">
      <button class="btn" id="playBtn" aria-live="polite">
        <span class="btn-label">Play</span>
      </button>
      <div class="color-menu" id="colorMenu" aria-label="Color settings menu">
        <button
          class="btn btn-icon"
          id="menuBtn"
          aria-label="Open color settings"
          title="Color settings"
        >
          <svg
            class="icon hamburger-icon"
            viewBox="0 0 24 24"
            aria-hidden="true"
          >
            <path
              d="M4 7h16M4 12h16M4 17h16"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
            />
          </svg>
          <svg class="icon close-icon" viewBox="0 0 24 24" aria-hidden="true">
            <path
              d="M6 6l12 12M18 6l-12 12"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
            />
          </svg>
        </button>
        <div class="menu-items" id="menuItems">
          <div class="menu-panel" id="menuPanel">
            <div class="menu-width" id="menuWidth">
              <button class="btn" id="colorBtn" aria-live="polite">
                <span class="btn-label">Color: Accent</span>
              </button>
              <button class="btn" id="randBtn" aria-live="polite">
                <span class="btn-label">Randomize Color</span>
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="fps" id="fps" aria-live="polite">FPS: â€”</div>
    <div class="cursor" id="cursor"></div>

    <!-- SVG filter for spiky/wavy ring distortion on beat -->
    <svg width="0" height="0" style="position: absolute">
      <defs>
        <filter
          id="cursorSpiky"
          x="-20%"
          y="-20%"
          width="140%"
          height="140%"
          filterUnits="objectBoundingBox"
          color-interpolation-filters="sRGB"
        >
          <!-- Turbulence driving displacement; parameters animated via JS -->
          <feTurbulence
            id="cursorTurbulence"
            type="fractalNoise"
            baseFrequency="1.0"
            numOctaves="1"
            seed="2"
            stitchTiles="stitch"
          />
          <feDisplacementMap
            id="cursorDisplace"
            in="SourceGraphic"
            in2="cursorTurbulence"
            scale="0"
            xChannelSelector="R"
            yChannelSelector="G"
          />
        </filter>
      </defs>
    </svg>

    <script type="module">
      import * as THREE from "https://unpkg.com/three@0.160.1/build/three.module.js";

      // Hide custom cursor on touch/coarse-pointer devices
      try {
        const isNoHover =
          window.matchMedia("(hover: none)").matches ||
          window.matchMedia("(pointer: coarse)").matches;
        if (isNoHover) {
          const c = document.getElementById("cursor");
          if (c) c.style.display = "none";
        }
      } catch {}

      // --- AUDIO ---
      const AUDIO_URL = "./Exil.mp3";
      // Start playback at 1:07 (67 seconds)
      const START_AT_SECONDS = 67;
      let audioCtx,
        audioEl,
        analyser,
        gainNode,
        isPlaying = false,
        sourceNode;
      const FFT_SIZE = 1024;
      let dataArray;
      function setupAudio() {
        if (audioCtx) return;
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioCtx.createAnalyser();
        analyser.fftSize = FFT_SIZE;
        dataArray = new Uint8Array(analyser.frequencyBinCount);
        audioEl = new Audio();
        audioEl.crossOrigin = "anonymous";
        audioEl.src = AUDIO_URL;
        audioEl.loop = true;
        audioEl.preload = "metadata";
        audioEl.addEventListener(
          "loadedmetadata",
          () => {
            try {
              audioEl.currentTime = START_AT_SECONDS;
              audioEl._startApplied = true;
            } catch {}
          },
          { once: true }
        );
        sourceNode = audioCtx.createMediaElementSource(audioEl);
        sourceNode.connect(analyser);
        gainNode = audioCtx.createGain();
        try {
          gainNode.gain.value = 0;
        } catch {}
        analyser.connect(gainNode);
        gainNode.connect(audioCtx.destination);
      }

      // --- SIMPLE FADES ---
      function fadeTo(target, durationSec = 0.3) {
        if (!audioCtx || !gainNode) return;
        const now = audioCtx.currentTime;
        const g = gainNode.gain;
        try {
          g.cancelScheduledValues(now);
          g.setValueAtTime(g.value, now);
          g.linearRampToValueAtTime(target, now + durationSec);
        } catch {}
      }
      function fadeInQuick() {
        fadeTo(1.0, 0.3);
      }
      function fadeOutQuick() {
        fadeTo(0.0, 0.25);
      }

      // --- ANALYSIS ---
      let lowFreq = 0,
        midFreq = 0,
        highFreq = 0;
      let kickDetected = false,
        kickEnergy = 0,
        kickImpact = 0,
        lastKickTime = 0;
      const kickDecay = 0.8,
        kickThreshold = 0.05;
      const historyLength = 4;
      const bandEnergies = Array(8).fill(0);
      const bandHistories = Array(8)
        .fill(0)
        .map(() => []);
      const bands = [
        [1, 4],
        [4, 9],
        [9, 20],
        [20, 40],
        [40, 80],
        [80, 160],
        [160, 300],
        [300, 500],
      ];
      const getWeightedAverage = (arr) => {
        if (!arr.length) return 0;
        let sum = 0,
          w = 0,
          maxv = 0;
        const emph = 1.5;
        for (let i = 0; i < arr.length; i++) {
          const v = arr[i] / 255;
          maxv = Math.max(maxv, v);
          sum += Math.pow(v, emph);
          w++;
        }
        const avg = sum / w;
        return avg * 0.7 + maxv * 0.3;
      };
      function updateFrequencies() {
        if (!isPlaying || !analyser) return;
        analyser.getByteFrequencyData(dataArray);
        for (let i = 0; i < bands.length; i++) {
          const [a, b] = bands[i];
          const slice = dataArray.slice(a, Math.min(b, dataArray.length));
          const e = getWeightedAverage(slice);
          bandEnergies[i] = e;
          bandHistories[i].unshift(e);
          if (bandHistories[i].length > historyLength) bandHistories[i].pop();
        }
        const kickAvg = bandEnergies[1];
        const kickHist = bandHistories[1];
        const recent =
          kickHist.slice(1).reduce((s, v) => s + v, 0) /
          (kickHist.length - 1 || 1);
        const jump = kickAvg - recent;
        const now = performance.now();
        const newKick =
          jump > kickThreshold * 1.2 &&
          kickAvg > 0.15 &&
          (!kickDetected || now - lastKickTime > 150);
        if (newKick) {
          kickDetected = true;
          kickEnergy = Math.min(1.0, kickAvg * 2.0);
          kickImpact = 10;
          lastKickTime = now;
          try {
            triggerCursorBeat(kickEnergy);
          } catch {}
        } else {
          kickEnergy *= kickDecay;
          if (kickEnergy < 0.05) kickDetected = false;
          if (kickImpact > 0) kickImpact--;
        }
        const combinedBass = (bandEnergies[1] * 1.2 + bandEnergies[2]) / 2.2;
        const combinedMid = (bandEnergies[3] + bandEnergies[4]) / 2.0;
        const combinedHigh =
          (bandEnergies[5] + bandEnergies[6] + bandEnergies[7]) / 3.0;
        const smooth = (p, t, a, d) => p + (t > p ? a : d) * (t - p);
        lowFreq = smooth(lowFreq, combinedBass, 0.9, 0.12);
        midFreq = smooth(midFreq, combinedMid, 0.4, 0.2);
        highFreq = smooth(highFreq, combinedHigh, 0.5, 0.2);
        lowFreq = Math.max(lowFreq, kickEnergy * 0.6);
        let bounce = 0.0;
        if (kickImpact > 0) bounce = Math.pow(kickImpact / 10, 0.6) * 0.03;
        bounce += kickEnergy * 0.025;
        uniforms.bounceEffect.value = bounce;
        uniforms.lowFreq.value = lowFreq;
        uniforms.midFreq.value = midFreq;
        uniforms.highFreq.value = highFreq;
        uniforms.kickEnergy.value = kickEnergy;
      }

      // --- THREE + SHADER ---
      const renderer = new THREE.WebGLRenderer({
        canvas: document.getElementById("gl"),
        antialias: true,
      });
      renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
      renderer.setSize(innerWidth, innerHeight);
      const scene = new THREE.Scene();
      const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

      const vertexShader = `varying vec2 vUv; void main(){ vUv=uv; gl_Position = projectionMatrix*modelViewMatrix*vec4(position,1.0); }`;
      const fragmentShader = `
precision highp float; varying vec2 vUv;
uniform vec2 iResolution; uniform float iTime; uniform vec2 iMouse;
uniform float lowFreq, midFreq, highFreq; uniform bool isPlaying; uniform float transitionFactor; uniform float lineStraightness; uniform float idleAnimation; uniform float idleWaveHeight; uniform float phase;
uniform float kickEnergy; uniform float bounceEffect; uniform float baseSpeed; uniform float idleSpeed; uniform float bassReactivity; uniform float midReactivity; uniform float highReactivity; uniform float bounceIntensity; uniform float waveIntensity; uniform float waveComplexity; uniform float rippleIntensity; uniform float lineThickness;
uniform bool enableGrain; uniform float grainIntensity; uniform float grainSpeed; uniform float grainMean; uniform float grainVariance; uniform int grainBlendMode;
/* Readability */
uniform vec4 safeRectA; uniform vec4 safeRectB; uniform float safeFeather; uniform float safeStrength; uniform float textRepel;
/* Colors */
uniform vec3 bgColorDown, bgColorUp; 
uniform vec3 l1In, l1Out, l2In, l2Out, l3In, l3Out; 
uniform vec3 accentBass, accentMid, accentHigh; 
uniform float colorLevel; // 0=minimal, 1=vivid
uniform float bgImpact; 

float sq(float v){return v*v;} float smoother(float e0,float e1,float x){float t=clamp((x-e0)/(e1-e0),0.0,1.0);return t*t*t*(t*(t*6.0-15.0)+10.0);} 
float sdBox(vec2 p, vec2 c, vec2 h){ vec2 d=abs(p-c)-h; return length(max(d,0.0)) + min(max(d.x,d.y),0.0);} 
float maskBox(vec2 p, vec2 c, vec2 h, float f){ float d=sdBox(p,c,h); return 1.0 - smoothstep(0.0, f, d);} 

float hash(vec2 p){ return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123); }
float vnoise(vec2 x){ vec2 i=floor(x); vec2 f=fract(x);
  float a=hash(i); float b=hash(i+vec2(1.0,0.0)); float c=hash(i+vec2(0.0,1.0)); float d=hash(i+vec2(1.0,1.0)); vec2 u=f*f*(3.0-2.0*f);
  return mix(a,b,u.x) + (c-a)*u.y*(1.0-u.x) + (d-b)*u.x*u.y;
}

vec3 applyGrain(vec3 color, vec2 uv){ if(!enableGrain) return color; float t=iTime*grainSpeed; float seed=dot(uv, vec2(12.9898,78.233)); float n=fract(sin(seed)*43758.5453+t); float g=(1.0/(grainVariance*sqrt(2.0*3.1415)))*exp(-((n-grainMean)*(n-grainMean))/(2.0*grainVariance*grainVariance)); vec3 gg=vec3(g)*(1.0-color); if(grainBlendMode==0){ color+=gg*grainIntensity; } else { color=max(color, gg*grainIntensity);} return color; }

void main(){ vec2 p=vUv; vec3 bg=mix(bgColorDown,bgColorUp, clamp(p.y*2.0,0.0,1.0));
  float speed=mix(idleSpeed, baseSpeed, transitionFactor);
  float str=mix(lineStraightness, 1.0, transitionFactor);
  float idle=idleWaveHeight * sin(p.x*5.0 + idleAnimation*0.2);
  float b=sq(lowFreq)*bassReactivity*transitionFactor; float m=sq(midFreq)*midReactivity*transitionFactor; float h=sq(highFreq)*highReactivity*transitionFactor; float bounce=bounceEffect*bounceIntensity*transitionFactor;

  float maskA=maskBox(p, safeRectA.xy, safeRectA.zw, safeFeather);
  float maskB=maskBox(p, safeRectB.xy, safeRectB.zw, safeFeather);
  float inSafe=max(maskA, maskB);
  float repel=textRepel * inSafe * (0.5 + 0.5*b);
  float repelDirA=sign(p.y - safeRectA.y); float repelDirB=sign(p.y - safeRectB.y);

  float baseAmp = mix(0.02, 0.045, transitionFactor);
  float curve = (baseAmp + 0.05*(b + 0.6*m)) * sin((6.25*p.x) + phase);
  float wave = (0.07*b + 0.05*m + 0.03*h)/str * (sin(p.x*18.0*waveComplexity) + 0.5*sin(p.x*36.0*waveComplexity));

  // LINE A (bass)
  float yA = 0.46 + idle + curve + wave + 0.28*b*sin(p.x*10.0 - iTime*2.0) + repel*mix(repelDirA,repelDirB,0.5) - bounce;
  float tA = lineThickness * (1.0 + 0.35*b);
  float dA = abs(p.y - yA) * (2.0 / tA);
  float sA = smoother(1.0 - clamp(dA,0.0,1.0),1.0,0.995);
  vec3 baseA = mix(l1In, l1Out, sA);
  vec3 accA = mix(baseA, accentBass, 0.85);
  vec3 cA = (1.0 - sA) * mix(baseA, accA, colorLevel * (0.35 + 0.65*b));

  // LINE B (mid)
  float yB = 0.5 + idle - curve + 0.24*m*sin(p.x*13.0 - iTime*1.6) + repel*0.7*mix(repelDirA,repelDirB,0.5) - 0.5*bounce;
  float tB = lineThickness * (1.0 + 0.28*m);
  float dB = abs(p.y - yB) * (2.0 / tB);
  float sB = smoother(1.0 - clamp(dB,0.0,1.0),1.0,0.995);
  vec3 baseB = mix(l2In, l2Out, sB);
  vec3 accB = mix(baseB, accentMid, 0.9);
  vec3 cB = (1.0 - sB) * mix(baseB, accB, colorLevel * (0.35 + 0.65*m));

  // LINE C (high)
  float yC = 0.54 + idle + 0.22*h*sin(p.x*20.0 - iTime*1.2) - 0.3*bounce + repel*0.5*mix(repelDirA,repelDirB,0.5);
  float tC = lineThickness * (1.0 + 0.22*h);
  float dC = abs(p.y - yC) * (2.0 / tC);
  float sC = smoother(1.0 - clamp(dC,0.0,1.0),1.0,0.995);
  vec3 baseC = mix(l3In, l3Out, sC);
  vec3 accC = mix(baseC, accentHigh, 0.95);
  vec3 cC = (1.0 - sC) * mix(baseC, accC, colorLevel * (0.35 + 0.65*h));

  float field = (1.0 - sA) + (1.0 - sB) + (1.0 - sC);
  float energy = clamp(0.55*b + 0.35*m + 0.7*h + 0.55*kickEnergy, 0.0, 1.0);
  float linInf = exp(-dA*1.2) + exp(-dB*1.2) + exp(-dC*1.2);
  vec2 warpUV = p + 0.003 * linInf * (0.3 + 0.7*energy) * vec2(
    vnoise(p*iResolution.xy*0.25 + iTime*0.35),
    vnoise(p*iResolution.xy*0.21 - iTime*0.27)
  );
  vec3 bgWarp = mix(bgColorDown,bgColorUp, clamp(warpUV.y*2.0,0.0,1.0));

  vec3 tintA = accentBass * (bgImpact * field * (0.08 + 0.70*b) * colorLevel);
  vec3 tintB = accentMid  * (bgImpact * field * (0.10 + 0.80*m) * colorLevel);
  vec3 tintC = accentHigh * (bgImpact * field * (0.12 + 0.90*h) * colorLevel);
  vec3 bgMixed = mix(bg, bgWarp, 0.18*(0.4 + 0.6*linInf)) + tintA + tintB + tintC;

  float atten = 1.0 - safeStrength * inSafe;
  vec3 f = bgMixed + (cA + cB + cC) * atten;

  // Dynamic film grain (multi-layer, animated)
  float t = iTime*grainSpeed; 
  float n1 = vnoise((p*iResolution.xy*0.65) + vec2(t*1.1, -t*0.8));
  float n2 = vnoise((p*iResolution.xy*1.3)  + vec2(-t*0.6, t*1.4));
  float n3 = vnoise((p*iResolution.xy*0.25) + vec2(t*0.3, t*0.25));
  float weave = 0.5 + 0.5*sin(t*2.7 + p.y*900.0);
  float n = (0.55*n1 + 0.35*n2 + 0.10*n3*weave);
  float dyn = grainIntensity + 0.1*energy + 0.22*linInf;
  vec3 grainHue = mix(vec3(1.0), accentMid, 0.35*colorLevel*highFreq);
  f += (n-0.5) * grainHue * dyn * 0.28;

  f = mix(f, vec3(1.0), 0.04 * kickEnergy * transitionFactor);
  f = applyGrain(f, p);
  gl_FragColor = vec4(f, 1.0);
}
      `;

      const uniforms = {
        iResolution: { value: new THREE.Vector2(innerWidth, innerHeight) },
        iTime: { value: 0 },
        iMouse: { value: new THREE.Vector2(0.5, 0.5) },
        lowFreq: { value: 0 },
        midFreq: { value: 0 },
        highFreq: { value: 0 },
        isPlaying: { value: false },
        transitionFactor: { value: 0 },
        lineStraightness: { value: 2.8 },
        idleAnimation: { value: 0 },
        phase: { value: 0 },
        idleWaveHeight: { value: 0.012 },
        kickEnergy: { value: 0 },
        bounceEffect: { value: 0 },
        baseSpeed: { value: 1.0 },
        idleSpeed: { value: 0.45 },
        bassReactivity: { value: 0.42 },
        midReactivity: { value: 0.45 },
        highReactivity: { value: 0.4 },
        bounceIntensity: { value: 0.12 },
        waveIntensity: { value: 0.06 },
        waveComplexity: { value: 2.0 },
        rippleIntensity: { value: 0.18 },
        lineThickness: { value: 1.6 },
        enableGrain: { value: true },
        grainIntensity: { value: 0.045 },
        grainSpeed: { value: 2.2 },
        grainMean: { value: 0.0 },
        grainVariance: { value: 0.5 },
        grainBlendMode: { value: 0 },
        // background colors
        bgColorDown: { value: new THREE.Vector3(11 / 255, 11 / 255, 16 / 255) },
        bgColorUp: { value: new THREE.Vector3(14 / 255, 12 / 255, 20 / 255) },
        // grayscale line base
        l1In: { value: new THREE.Vector3(0.92, 0.92, 0.92) },
        l1Out: { value: new THREE.Vector3(0.78, 0.78, 0.78) },
        l2In: { value: new THREE.Vector3(0.8, 0.8, 0.8) },
        l2Out: { value: new THREE.Vector3(0.66, 0.66, 0.66) },
        l3In: { value: new THREE.Vector3(0.68, 0.68, 0.68) },
        l3Out: { value: new THREE.Vector3(0.54, 0.54, 0.54) },
        // accents
        accentBass: { value: new THREE.Vector3(1.0, 0.83, 0.63) },
        accentMid: { value: new THREE.Vector3(0.83, 0.74, 1.0) },
        accentHigh: { value: new THREE.Vector3(0.74, 0.63, 1.0) },
        colorLevel: { value: 0.55 },
        // readability
        safeRectA: { value: new THREE.Vector4(0.5, 0.82, 0.36, 0.1) },
        safeRectB: { value: new THREE.Vector4(0.5, 0.2, 0.34, 0.1) },
        safeFeather: { value: 0.08 },
        safeStrength: { value: 0.72 },
        textRepel: { value: 0.016 },
        // background impact
        bgImpact: { value: 0.2 },
      };

      const material = new THREE.ShaderMaterial({
        vertexShader,
        fragmentShader,
        uniforms,
        transparent: false,
      });
      const mesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), material);
      scene.add(mesh);

      function makeNoiseTex() {
        const s = 256;
        const c = document.createElement("canvas");
        c.width = s;
        c.height = s;
        const ctx = c.getContext("2d");
        const img = ctx.createImageData(s, s);
        const d = img.data;
        for (let i = 0; i < d.length; i += 4) {
          const v = (Math.random() * 255) | 0;
          d[i] = d[i + 1] = d[i + 2] = v;
          d[i + 3] = 255;
        }
        ctx.putImageData(img, 0, 0);
        document.getElementById(
          "noise"
        ).style.backgroundImage = `url(${c.toDataURL("image/png")})`;
      }
      makeNoiseTex();

      // Sync safe rectangles to overlay positions
      const topBox = document.getElementById("titleTop");
      const bottomBox = document.getElementById("titleBottom");
      const rectToSafe = (r) => {
        const w = innerWidth,
          h = innerHeight;
        const cx = (r.left + r.width / 2) / w;
        const cy = 1.0 - (r.top + r.height / 2) / h;
        const hx = (r.width / w) * 0.5;
        const hy = (r.height / h) * 0.5;
        return [cx, cy, hx, hy];
      };
      function updateSafeRects() {
        const rt = topBox.getBoundingClientRect();
        const rb = bottomBox.getBoundingClientRect();
        const [cxA, cyA, hxA, hyA] = rectToSafe(rt);
        const [cxB, cyB, hxB, hyB] = rectToSafe(rb);
        uniforms.safeRectA.value.set(cxA, cyA, hxA, hyA);
        uniforms.safeRectB.value.set(cxB, cyB, hxB, hyB);
      }
      updateSafeRects();
      setTimeout(updateSafeRects, 150);

      // Cursor state
      const cursorEl = document.getElementById("cursor");
      let cursorTX = innerWidth * 0.5,
        cursorTY = innerHeight * 0.5,
        cursorX = cursorTX,
        cursorY = cursorTY;
      let lastMouseX = cursorTX,
        lastMouseY = cursorTY;
      let magnetBtn = null;
      let cursorBeat = 0;
      const turbEl = document.getElementById("cursorTurbulence");
      const dispEl = document.getElementById("cursorDisplace");
      function triggerCursorBeat(strength) {
        cursorBeat = Math.min(1, Math.max(cursorBeat, 0.25 + strength * 0.5));
      }

      // Loop
      let last = performance.now(),
        frames = 0,
        acc = 0;
      const fpsEl = document.getElementById("fps");
      let transition = 0;
      let phase = 0;
      function animate(now) {
        requestAnimationFrame(animate);
        const dt = (now - last) / 1000;
        last = now;
        const timeScale = 0.6;
        uniforms.iTime.value += dt * timeScale;
        uniforms.idleAnimation.value += dt * timeScale;
        updateFrequencies();
        const rate = 0.03;
        if (isPlaying && transition < 1.0) {
          transition = Math.min(transition + rate, 1.0);
        } else if (!isPlaying && transition > 0.0) {
          transition = Math.max(transition - rate, 0.0);
          const k = Math.max(0, 1 - 6 * dt);
          lowFreq *= k;
          midFreq *= k;
          highFreq *= k;
          kickEnergy *= k;
          uniforms.lowFreq.value = lowFreq;
          uniforms.midFreq.value = midFreq;
          uniforms.highFreq.value = highFreq;
          uniforms.kickEnergy.value = kickEnergy;
          if (transition === 0) {
            lowFreq = midFreq = highFreq = kickEnergy = 0;
            uniforms.lowFreq.value =
              uniforms.midFreq.value =
              uniforms.highFreq.value =
              uniforms.kickEnergy.value =
                0;
            uniforms.bounceEffect.value = 0;
          }
        }
        const curSpeed =
          uniforms.idleSpeed.value * (1 - transition) +
          uniforms.baseSpeed.value * transition;
        phase += curSpeed * (dt * timeScale);
        uniforms.phase.value = phase;
        uniforms.transitionFactor.value = transition;
        uniforms.isPlaying.value = isPlaying;
        renderer.render(scene, camera);
        cursorBeat = Math.max(0, cursorBeat - dt * 3.2);
        const beatScale = 1 + 0.35 * (1 - Math.pow(1 - cursorBeat, 2));
        const snapActive = cursorEl.classList.contains("btn-hover");
        if (snapActive && magnetBtn && document.body.contains(magnetBtn)) {
          const br = magnetBtn.getBoundingClientRect();
          const cx = br.left + br.width / 2;
          const cy = br.top + br.height / 2;
          const dx = lastMouseX - cx;
          const dy = lastMouseY - cy;
          const k = 0.12;
          const maxOff = 8;
          const offX = Math.max(-maxOff, Math.min(maxOff, dx * k));
          const offY = Math.max(-maxOff, Math.min(maxOff, dy * k));
          cursorTX = cx + offX;
          cursorTY = cy + offY;
          cursorEl.style.width = `${Math.max(1, br.width)}px`;
          cursorEl.style.height = `${Math.max(1, br.height)}px`;
          cursorEl.style.setProperty("--ring-ox", "0px");
          cursorEl.style.setProperty("--ring-oy", "0px");
          magnetBtn.style.setProperty("--magnet-x", `${offX}px`);
          magnetBtn.style.setProperty("--magnet-y", `${offY}px`);
        } else {
          cursorEl.style.setProperty("--ring-ox", "0px");
          cursorEl.style.setProperty("--ring-oy", "0px");
          if (magnetBtn) {
            try {
              magnetBtn.style.setProperty("--magnet-x", "0px");
              magnetBtn.style.setProperty("--magnet-y", "0px");
            } catch {}
          }
        }
        const follow = snapActive ? 18 : 12;
        const a = 1 - Math.exp(-follow * dt);
        cursorX += (cursorTX - cursorX) * a;
        cursorY += (cursorTY - cursorY) * a;
        const baseHoverScale = cursorEl.classList.contains("snap") ? 1.06 : 1.0;
        const nonDefaultState =
          snapActive || cursorEl.classList.contains("text-hover");
        const effectiveBeatScale = nonDefaultState ? 1.0 : beatScale;
        const finalScaleNum = baseHoverScale * effectiveBeatScale;
        const finalScale = finalScaleNum.toFixed(3);
        cursorEl.style.transform = `translate(${cursorX}px,${cursorY}px) translate(-50%, -50%) scale(${finalScale})`;
        cursorEl.classList.toggle("beat", cursorBeat > 0.03);
        if (dispEl && turbEl) {
          const disp = cursorBeat > 0 ? 4 + 14 * cursorBeat : 0;
          dispEl.setAttribute("scale", disp.toFixed(2));
          const baseF = 0.55 + 0.55 * cursorBeat;
          turbEl.setAttribute("baseFrequency", baseF.toFixed(3));
          turbEl.setAttribute("seed", String(((now * 0.08) | 0) % 10000));
        }
        acc += dt;
        frames++;
        if (acc >= 0.25) {
          fpsEl.textContent = `FPS: ${Math.round(frames / acc)}`;
          frames = 0;
          acc = 0;
        }
      }
      requestAnimationFrame(animate);

      // EVENTS
      addEventListener("resize", () => {
        renderer.setSize(innerWidth, innerHeight);
        uniforms.iResolution.value.set(innerWidth, innerHeight);
        updateSafeRects();
      });
      addEventListener("mousemove", (e) => {
        uniforms.iMouse.value.set(e.clientX, e.clientY);
        cursorTX = e.clientX;
        cursorTY = e.clientY;
        lastMouseX = e.clientX;
        lastMouseY = e.clientY;
        let btnEl = null;
        if (document.elementsFromPoint) {
          const stack = document.elementsFromPoint(e.clientX, e.clientY);
          for (const el of stack) {
            const b = el.closest && el.closest("button,.btn");
            if (b) {
              btnEl = b;
              break;
            }
          }
        }
        if (!btnEl) btnEl = e.target.closest("button,.btn");
        let linkEl = null;
        if (document.elementsFromPoint) {
          const stack = document.elementsFromPoint(e.clientX, e.clientY);
          for (const el of stack) {
            const a = el.closest && el.closest("a");
            if (a) {
              linkEl = a;
              break;
            }
          }
        }
        if (!linkEl) linkEl = e.target.closest("a");

        cursorEl.classList.toggle("btn-hover", !!btnEl);
        cursorEl.classList.toggle("text-hover", !btnEl && !!linkEl);
        cursorEl.classList.toggle("snap", !!btnEl);
        if (btnEl) {
          const br = btnEl.getBoundingClientRect();
          const cx = br.left + br.width / 2;
          const cy = br.top + br.height / 2;
          const dx = e.clientX - cx;
          const dy = e.clientY - cy;
          const k = 0.12;
          const maxOff = 8;
          const offX = Math.max(-maxOff, Math.min(maxOff, dx * k));
          const offY = Math.max(-maxOff, Math.min(maxOff, dy * k));
          cursorTX = cx + offX;
          cursorTY = cy + offY;
          cursorEl.style.setProperty("--ring-ox", "0px");
          cursorEl.style.setProperty("--ring-oy", "0px");
          cursorEl.style.width = `${Math.max(1, br.width)}px`;
          cursorEl.style.height = `${Math.max(1, br.height)}px`;
          if (magnetBtn && magnetBtn !== btnEl) {
            try {
              magnetBtn.style.setProperty("--magnet-x", "0px");
              magnetBtn.style.setProperty("--magnet-y", "0px");
            } catch {}
          }
          btnEl.style.setProperty("--magnet-x", `${offX}px`);
          btnEl.style.setProperty("--magnet-y", `${offY}px`);
          magnetBtn = btnEl;
        } else {
          cursorEl.style.width = "";
          cursorEl.style.height = "";
          cursorEl.style.setProperty("--ring-ox", "0px");
          cursorEl.style.setProperty("--ring-oy", "0px");
          if (magnetBtn) {
            try {
              magnetBtn.style.setProperty("--magnet-x", "0px");
              magnetBtn.style.setProperty("--magnet-y", "0px");
            } catch {}
          }
          magnetBtn = null;
        }
      });

      const playBtn = document.getElementById("playBtn");
      const playLabel = playBtn.querySelector(".btn-label");
      playBtn.onclick = async () => {
        setupAudio();
        if (audioCtx.state === "suspended") await audioCtx.resume();
        if (!isPlaying) {
          if (audioEl.readyState >= 1 && !audioEl._startApplied) {
            try {
              audioEl.currentTime = START_AT_SECONDS;
              audioEl._startApplied = true;
            } catch {}
          }
          try {
            if (gainNode) gainNode.gain.value = 0;
          } catch {}
          await audioEl.play();
          isPlaying = true;
          if (playLabel) playLabel.textContent = "Stop";
          fadeInQuick();
        } else {
          fadeOutQuick();
          setTimeout(() => {
            audioEl.pause();
            isPlaying = false;
            if (playLabel) playLabel.textContent = "Play";
          }, 260);
        }
      };

      // Color mode toggler
      const colorBtn = document.getElementById("colorBtn");
      const colorLabel = colorBtn.querySelector(".btn-label");
      const modes = [
        { label: "Minimal", level: 0.15 },
        { label: "Accent", level: 0.55 },
        { label: "Vivid", level: 0.95 },
      ];
      let modeIdx = 1;
      const setMode = (i) => {
        modeIdx = i % modes.length;
        uniforms.colorLevel.value = modes[modeIdx].level;
        if (colorLabel)
          colorLabel.textContent = `Color: ${modes[modeIdx].label}`;
      };
      colorBtn.onclick = () => setMode(modeIdx + 1);
      addEventListener("keydown", (e) => {
        if (e.key.toLowerCase() === "c") setMode(modeIdx + 1);
      });

      // Randomize color palette
      const randBtn = document.getElementById("randBtn");
      function hslToRgb(h, s, l) {
        h = ((h % 360) + 360) % 360;
        s = Math.min(Math.max(s, 0), 1);
        l = Math.min(Math.max(l, 0), 1);
        const c = (1 - Math.abs(2 * l - 1)) * s;
        const x = c * (1 - Math.abs(((h / 60) % 2) - 1));
        const m = l - c / 2;
        let r = 0,
          g = 0,
          b = 0;
        if (h < 60) {
          r = c;
          g = x;
          b = 0;
        } else if (h < 120) {
          r = x;
          g = c;
          b = 0;
        } else if (h < 180) {
          r = 0;
          g = c;
          b = x;
        } else if (h < 240) {
          r = 0;
          g = x;
          b = c;
        } else if (h < 300) {
          r = x;
          g = 0;
          b = c;
        } else {
          r = c;
          g = 0;
          b = x;
        }
        return [r + m, g + m, b + m];
      }
      function rand(min, max) {
        return Math.random() * (max - min) + min;
      }
      function pickPalette() {
        const baseH = rand(0, 360);
        const satAcc = rand(0.25, 0.5);
        const lightAcc = rand(0.6, 0.78);
        const hMid = baseH;
        const hHigh = baseH + rand(8, 24);
        const hBass = baseH - rand(18, 36);
        const [r1, g1, b1] = hslToRgb(hBass, satAcc * 0.9, lightAcc * 0.9);
        const [r2, g2, b2] = hslToRgb(hMid, satAcc, lightAcc);
        const [r3, g3, b3] = hslToRgb(hHigh, satAcc * 0.95, lightAcc * 0.92);
        const [rb1, gb1, bb1] = hslToRgb(baseH - 6, satAcc * 0.25, 0.08);
        const [rb2, gb2, bb2] = hslToRgb(baseH + 6, satAcc * 0.3, 0.11);
        return {
          bass: [r1, g1, b1],
          mid: [r2, g2, b2],
          high: [r3, g3, b3],
          bgDown: [rb1, gb1, bb1],
          bgUp: [rb2, gb2, bb2],
        };
      }
      function applyPalette(p) {
        uniforms.accentBass.value.set(p.bass[0], p.bass[1], p.bass[2]);
        uniforms.accentMid.value.set(p.mid[0], p.mid[1], p.mid[2]);
        uniforms.accentHigh.value.set(p.high[0], p.high[1], p.high[2]);
        uniforms.bgColorDown.value.set(p.bgDown[0], p.bgDown[1], p.bgDown[2]);
        uniforms.bgColorUp.value.set(p.bgUp[0], p.bgUp[1], p.bgUp[2]);
      }
      randBtn.onclick = () => {
        const p = pickPalette();
        applyPalette(p);
      };
      addEventListener("keydown", (e) => {
        if (e.key.toLowerCase() === "r") {
          const p = pickPalette();
          applyPalette(p);
        }
      });

      // Hamburger toggle for color settings
      (function colorMenuToggle() {
        const menuWrap = document.getElementById("colorMenu");
        const menuBtn = document.getElementById("menuBtn");
        const colorBtnEl = document.getElementById("colorBtn");
        const randBtnEl = document.getElementById("randBtn");
        const items = document.getElementById("menuItems");
        const widthWrap = document.getElementById("menuWidth");
        const panel = document.getElementById("menuPanel");

        if (
          !menuWrap ||
          !menuBtn ||
          !colorBtnEl ||
          !randBtnEl ||
          !items ||
          !widthWrap
        )
          return;

        let hideTimer = null;
        const AUTO_HIDE_MS = 20000;
        let isOpen = false;

        const clearHideTimer = () => {
          if (hideTimer) {
            clearTimeout(hideTimer);
            hideTimer = null;
          }
        };

        const scheduleHide = (delay = AUTO_HIDE_MS) => {
          clearHideTimer();
          hideTimer = setTimeout(() => setOpen(false), delay);
        };

        function setOpen(open) {
          isOpen = open;
          clearHideTimer();
          if (open) {
            menuWrap.classList.add("anim-opening");
            menuWrap.classList.remove("anim-closing");
            menuWrap.classList.add("open");
            menuBtn.setAttribute("aria-expanded", "true");
            menuBtn.setAttribute("aria-label", "Close color settings");
            menuBtn.setAttribute("title", "Close");
            setTimeout(() => menuWrap.classList.remove("anim-opening"), 400);
            scheduleHide();
          } else {
            menuWrap.classList.add("anim-closing");
            menuWrap.classList.remove("anim-opening");
            menuWrap.classList.remove("open");
            menuBtn.setAttribute("aria-expanded", "false");
            menuBtn.setAttribute("aria-label", "Open color settings");
            menuBtn.setAttribute("title", "Color settings");
            setTimeout(() => menuWrap.classList.remove("anim-closing"), 400);
          }
        }

        menuBtn.addEventListener("click", () => setOpen(!isOpen));

        [colorBtnEl, randBtnEl].forEach((b) =>
          b.addEventListener("click", () => scheduleHide(AUTO_HIDE_MS))
        );
        menuWrap.addEventListener("mouseenter", () => clearHideTimer());
        menuWrap.addEventListener("mouseleave", () => {
          if (isOpen) scheduleHide(1200);
        });

        // ESC closes
        addEventListener("keydown", (e) => {
          if (e.key === "Escape") setOpen(false);
        });
      })();
    </script>
  </body>
</html>
